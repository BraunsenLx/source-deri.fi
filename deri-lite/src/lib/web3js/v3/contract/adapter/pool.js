// this file is generated by script, don't modify it !!!
import { bg, max, fromWei, getNetworkName } from "../../../shared/utils/index.js";
import { ADDRESS_ZERO, debug, SECONDS_IN_A_DAY } from "../../../shared/config/constant.js";
import { DeriEnv, Env } from "../../../shared/config/env.js";
import {
  dTokenFactory,
  ERC20Factory,
  symbolImplementationFuturesFactory,
  symbolImplementationOptionFactory,
  symbolImplementationPowerFactory,
  symbolManagerImplementationFactory,
  vaultImplementationFactory,
  vBEP20Factory,
  vBNBFactory,
} from "../factory/rest.js";
import { deriLensFactoryProxy } from "../factory/deri_lens.js";
import {
  overrideMethods,
  processMethod,
  processTxMethod,
  classAdapter,
  range,
  getBTokenOrder,
} from "./shared.js";
import { calculateDpmmCost } from "../../utils/futures.js";
import { getDeriLensConfig, isArbiChain, isBSCChain, isOptionSymbol, nativeCoinSymbols, onChainSymbols } from '../../config.js'
import { tokenToName } from "../../utils/misc.js";
import { getInitialMarginRequired, getIntrinsicPrice } from "../../utils/option.js";
import { normalizeSymbolUnit } from "../../../shared/config/token.js";
import { getSymbolsOracleInfoForLens } from "../../utils/oracle.js";
import { normalizeBNB } from "../../utils/config.js";
import { isPowerSymbol } from "../../utils/power.js";
import { getLensPropAlias } from "../../utils/alias.js";

const delayMs = (ms) => new Promise((resolve) => setTimeout(resolve, ms))
const bToken0Order = 10000
// const getInfoInterval = 500

export const poolImplementationAdapter = (klass) => {
  // klass = processMethod(klass, 'symbol', []);

  klass = classAdapter(klass, 'init', async function (accountAddress = ADDRESS_ZERO, isEstimatedApi = false) {
    await this._init();
    // init deri lens
    if (!this.deriLens) {
      this.addresses.deriLens = getDeriLensConfig(
        DeriEnv.get(),
        this.chainId
      ).address;
      this.deriLens = deriLensFactoryProxy(this.chainId, this.addresses.deriLens);
    }
    if (!this.b0Address) {
      this.b0Address = await this.tokenB0Address()
    }
    if ((this.symbols && this.symbols.length > 0) && isEstimatedApi) {
      // not fetch getInfo for isEstimatedApi
      return
    }
    await this.getInfo(accountAddress)
    if (!this.inited) {
      this.inited = true
    }
  });

  klass = classAdapter(
    klass,
    "getInfo",
    async function (accountAddress = ADDRESS_ZERO) {
      await this.deriLens._init();
      let info
      if (!this.symbolNames) {
        info = await this.deriLens.getInfo(this.contractAddress, accountAddress, []);
        this.symbolNames = info.symbolsInfo.map((s) => s.symbol)
      }
      const startAt = Date.now()
      debug() &&  console.log(`-- deriLens.getInfo start(${startAt})`)
      let oracleSignatures = await getSymbolsOracleInfoForLens(this.chainId, this.symbolNames)
      info = await this.deriLens.getInfo(this.contractAddress, accountAddress, oracleSignatures);
      debug() && console.log(`-- deriLens.getInfo end  (${startAt}): ${(Date.now() - startAt)/1000}`)
      // console.log('info', info)
      const { poolInfo, marketsInfo, symbolsInfo, lpInfo, tdInfo } = info;
      this.addresses = this.addresses || {};
      if (!this.addresses.lToken) {
        this.addresses.lToken = poolInfo.lToken;
        this.addresses.pToken = poolInfo.pToken;
        this.addresses.symbolManager = poolInfo.symbolManager;
        this.addresses.swapper = poolInfo.swapper;
        this.addresses.tokenB0 = poolInfo.tokenB0;
        this.addresses.tokenWETH = poolInfo.tokenWETH;
        this.addresses.vTokenB0 = getLensPropAlias('vTokenB0', poolInfo);
        this.addresses.vTokenETH = getLensPropAlias('vTokenETH', poolInfo);
        this.addresses.implementation = poolInfo.implementation;
        this.addresses.protocolFeeCollector = poolInfo.protocolFeeCollector;
      }

      this.parameters = this.parameters || {};
      if (!this.parameters.minRatioB0) {
        this.parameters.minRatioB0 = poolInfo.minRatioB0;
        this.parameters.reserveRatioB0 = poolInfo.reserveRatioB0;
        this.parameters.liquidationRewardCutRatio =
          poolInfo.liquidationRewardCutRatio;
        this.parameters.minLiquidationReward = poolInfo.minLiquidationReward;
        this.parameters.maxLiquidationReward = poolInfo.maxLiquidationReward;
        this.parameters.protocolFeeCollectRatio =
          poolInfo.protocolFeeCollectRatio;
        this.parameters.poolInitialMarginMultiplier =
          poolInfo.poolInitialMarginMultiplier;
      }

      // contract instance
      if (!this.lToken || !this.pToken) {
        this.lToken = dTokenFactory(this.chainId, this.addresses.lToken);
        this.pToken = dTokenFactory(this.chainId, this.addresses.pToken);
        this.symbolManager = symbolManagerImplementationFactory(
          this.chainId,
          this.addresses.symbolManager
        );
        this.tokenB0 = ERC20Factory(this.chainId, this.addresses.tokenB0);
        // console.log(await this.tokenB0.symbol())
        this.tokenETH = ERC20Factory(this.chainId, this.addresses.tokenWETH);
        this.vtokenB0 = vBEP20Factory(this.chainId, this.addresses.vTokenB0);
        this.vtokenETH = vBNBFactory(this.chainId, this.addresses.vTokenETH);
        if (this.addresses.xvsToken) {
          this.xvsToken = ERC20Factory(this.chainId, this.addresses.xvsAddress);
        }
      }
      // bTokens
      for (let i = 0; i < marketsInfo.length; i++) {
        const market = marketsInfo[i];
        this[tokenToName(normalizeBNB(this.chainId, getLensPropAlias('underlyingSymbol', market)))] = ERC20Factory(
          this.chainId, getLensPropAlias('underlying', market)
        );
        this[tokenToName(getLensPropAlias('vTokenSymbol', market))] = ERC20Factory(
          this.chainId, getLensPropAlias('vTokenSymbol', market)
        );
      }
      this.state = this.state || {};
      this.state.liquidity = poolInfo.liquidity;
      this.state.lpsPnl = poolInfo.lpsPnl;
      this.state.cumulativePnlPerLiquidity = poolInfo.cumulativePnlPerLiquidity;
      this.state.protocolFeeAccrued = poolInfo.protocolFeeAccrued;
      // misc
      [this.parameters.symbolsLength, this.state.balanceOfB0] =
        await Promise.all([
          this.symbolManager.getSymbolsLength(),
          this.tokenB0.balanceOf(this.contractAddress),
        ]);
      this.parameters.symbolsLength = parseInt(this.parameters.symbolsLength);
      this.bTokenDecimals = this.bTokenDecimals || {}
      if (this.bTokens && this.bTokens.length > 0) {
        this.bTokens = this.bTokens.reduce((acc, b) => {
          const market = marketsInfo.find((m) => normalizeBNB(this.chainId, getLensPropAlias('underlyingSymbol', m)) === b.bTokenSymbol)
          if (market) {
            acc.push({
              ...b,
              bTokenPrice: this.bTokenDecimals[b.bTokenAddress] && isBSCChain(this.chainId)
                ? bg(
                  getLensPropAlias('underlyingPrice', market),
                  this.bTokenDecimals[b.bTokenAddress] - 18
                ).toString()
                : getLensPropAlias('underlyingPrice', market),
              vTokenBalance: getLensPropAlias('vTokenBalance' , market),
              exchangeRate: market.exchangeRate || '',
            })
          } else {
            acc.push(b)
          }
          return acc
        }, []);
      } else {
        this.bTokens = marketsInfo.map((m) => ({
          bTokenSymbol: normalizeBNB(this.chainId, getLensPropAlias('underlyingSymbol', m)),
          bTokenAddress: getLensPropAlias('underlying', m),
          vTokenAddress: getLensPropAlias('vToken', m),
          vTokenSymbol: getLensPropAlias('vTokenSymbol', m),
          bTokenPrice: getLensPropAlias('underlyingPrice', m),
          vTokenBalance: getLensPropAlias('vTokenBalance' , m),
          exchangeRate: m.exchangeRate || '',
          collateralFactor: m.collateralFactor || '',
          bTokenOrder: getBTokenOrder(this.chainId, normalizeBNB(this.chainId, getLensPropAlias('underlyingSymbol', m))),
        }));
        this.bTokens = this.bTokens.sort((x, y) => {
          return x.bTokenAddress === this.b0Address
            ? -bToken0Order
            : y.bTokenAddress === this.b0Address
              ? bToken0Order
              : x.bTokenOrder - y.bTokenOrder;
        })
        // update btoken decimals
        const decimals = await Promise.all(
          this.bTokens.map((b) =>
            this[tokenToName(normalizeBNB(this.chainId, b.bTokenSymbol))].decimals()
          )
        );
        // use as decimals cache
        this.bTokenDecimals = {}
        for (let i = 0; i < this.bTokens.length; i++) {
          this.bTokens[i].bTokenDecimals = decimals[i];
          if (decimals[i] !== '18') {
            this.bTokenDecimals[this.bTokens[i].bTokenAddress] = parseInt(decimals[i])
            if (isBSCChain(this.chainId)) {
              this.bTokens[i].bTokenPrice = bg(this.bTokens[i].bTokenPrice, parseInt(decimals[i]) - 18).toString()
            }
          }
        }
      }
      // b0 must at index 0
      this.bTokenSymbols = this.bTokens.map((b) => b.bTokenSymbol);
      // filter USDT
      if (DeriEnv.get() !== Env.PROD && isArbiChain(this.chainId)) {
        this.bTokens = this.bTokens.filter((b) => b.bTokenSymbol !== 'USDT')
      }

      if (this.symbols && this.symbols.length > 0) {
        this.symbols = this.symbols.reduce((acc, symbol) => {
          const s = symbolsInfo.find((si) => si.symbol === symbol.symbol)
          if (s) {
            const res = {
              ...symbol,
              K: s.K,
              cumulativeFundingPerVolume: s.cumulativeFundingPerVolume,
              curCumulativeFundingPerVolume: s.curCumulativeFundingPerVolume,
              curIndexPrice: s.curIndexPrice,
              curVolatility: s.curVolatility,
              delta: s.delta,
              funding: s.funding,
              fundingTimestamp: s.fundingTimestamp,
              indexPrice: s.indexPrice,
              initialMarginRequired: s.initialMarginRequired,
              markPrice: s.markPrice,
              nPositionHolders: s.nPositionHolders,
              netCost: s.netCost,
              netVolume: s.netVolume,
              timeValue: s.timeValue,
              tradersPnl: s.tradersPnl,
              u: s.u,
              power: s.power || "",
              hT: s.hT || "",
              powerPrice: s.powerPrice || "",
            }
            if (s.category === 'power') {
              res.theoreticalPrice = s.theoreticalPrice
            }
            acc.push(res)
          } else {
            acc.push(symbol)
          }
          return acc
        }, [])
      } else {
        this.symbols = symbolsInfo.map((s) => ({
          alpha: s.alpha,
          category: s.category,
          K: s.K,
          cumulativeFundingPerVolume: s.cumulativeFundingPerVolume,
          curCumulativeFundingPerVolume: s.curCumulativeFundingPerVolume,
          curIndexPrice: s.curIndexPrice,
          curVolatility: s.curVolatility,
          delta: s.delta,
          feeRatio: s.feeRatio,
          feeRatioITM: s.feeRatioITM,
          feeRatioOTM: s.feeRatioOTM,
          funding: s.funding,
          fundingPeriod: s.fundingPeriod,
          fundingTimestamp: s.fundingTimestamp,
          implementation: s.implementation,
          indexPrice: s.indexPrice,
          initialMarginRatio: s.initialMarginRatio,
          minInitialMarginRatio: s.minInitialMarginRatio,
          initialMarginRequired: s.initialMarginRequired,
          isCall: s.isCall,
          isCloseOnly: s.isCloseOnly,
          maintenanceMarginRatio: s.maintenanceMarginRatio,
          manager: s.manager,
          markPrice: s.markPrice,
          minTradeVolume: s.minTradeVolume,
          nPositionHolders: s.nPositionHolders,
          netCost: s.netCost,
          netVolume: s.netVolume,
          oracleManager: s.oracleManager,
          priceId: s.priceId,
          pricePercentThreshold: s.pricePercentThreshold,
          strikePrice: s.strikePrice,
          symbol: s.symbol,
          symbolAddress: s.symbolAddress,
          symbolId: s.symbolId,
          timeThreshold: s.timeThreshold,
          timeValue: s.timeValue,
          tradersPnl: s.tradersPnl,
          u: s.u,
          volatilityId: s.volatilityId,
          power: s.power || "",
          hT: s.hT || "",
          powerPrice: s.powerPrice || "",
          theoreticalPrice: s.category === 'power' ? s.theoreticalPrice : "",
        }));
      }
      // symbol instance
      if (this.symbols[0] && !this[tokenToName(this.symbols[0].symbol)]) {
        for (let i = 0; i < this.symbols.length; i++) {
          const symbol = this.symbols[i];
          const symbolName = tokenToName(symbol.symbol);
          if (isOptionSymbol(symbol)) {
            this[symbolName] = symbolImplementationOptionFactory(
              this.chainId,
              symbol.symbolAddress
            );
          } else if (isPowerSymbol(symbol)) {
            this[symbolName] = symbolImplementationPowerFactory(
              this.chainId,
              symbol.symbolAddress
            );
          } else {
            this[symbolName] = symbolImplementationFuturesFactory(
              this.chainId,
              symbol.symbolAddress
            );
          }
        }
      }

      this.assets = this.assets || []
      this.margins = this.margins || []
      this.positions = this.positions || []
      if (accountAddress !== ADDRESS_ZERO) {
        this.account = this.account || {}
        this.account.address = accountAddress;
        if (lpInfo.lTokenId !== '0') {
          this.account.lTokenId = lpInfo.lTokenId;
          this.account.lpVault = lpInfo.vault;
        }
        if (tdInfo.pTokenId !== '0') {
          this.account.pTokenId = tdInfo.pTokenId;
          this.account.tdVault = tdInfo.vault;
        }
        if (lpInfo.vault !== ADDRESS_ZERO && !this.lpVault) {
          this.lpVault = vaultImplementationFactory(this.chainId, lpInfo.vault);
          if (!this.addresses.xvsToken && isBSCChain(this.chainId)) {
            this.addresses.xvsToken = await this.lpVault.tokenXVS()
            this.xvsToken = ERC20Factory(this.chainId, this.addresses.xvsToken)
          }
        }
        if (tdInfo.vault !== ADDRESS_ZERO && !this.tdVault) {
          this.tdVault = vaultImplementationFactory(this.chainId, tdInfo.vault);
          if (!this.addresses.xvsToken && isBSCChain(this.chainId)) {
            this.addresses.xvsToken = await this.tdVault.tokenXVS()
            this.xvsToken = ERC20Factory(this.chainId, this.addresses.xvsToken)
          }
        }
        this.account.liquidity = lpInfo.liquidity;
        this.account.cumulativePnlPerLiquidity =
          lpInfo.cumulativePnlPerLiquidity;
        this.account.lpVaultLiquidity = lpInfo.vaultLiquidity;
        this.account.lpAmountB0 = lpInfo.amountB0;
        // this.account.xvsBalance = xvsBalance;
        if (lpInfo.markets.length > 0) {
          this.assets = lpInfo.markets.map((m) => ({
            bTokenAddress: getLensPropAlias('underlying', m),
            vTokenAddress: getLensPropAlias('vToken', m),
            bTokenSymbol: normalizeBNB(this.chainId, getLensPropAlias('underlyingSymbol', m)),
            vTokenSymbol: getLensPropAlias('vTokenSymbol', m),
            bTokenPrice: this.bTokens.find((b) => b.bTokenSymbol === normalizeBNB(this.chainId, getLensPropAlias('underlyingSymbol', m))).bTokenPrice,
            exchangeRate: m.exchangeRate || '',
            vTokenBalance: getLensPropAlias('vTokenBalance', m),
          }));
          for (let asset of this.assets) {
            asset.vaultBalance = (!asset.exchangeRate)
              ? asset.vTokenBalance
              : this.bTokenDecimals[asset.bTokenAddress]   // fix non-18 decimal bToken issue
                ? bg(
                  bg(asset.vTokenBalance).times(asset.exchangeRate),
                  18 - this.bTokenDecimals[asset.bTokenAddress]
                ).toString()
                : bg(asset.vTokenBalance).times(asset.exchangeRate).toString();
          }
        } else {
          this.assets = []
        }
        this.account.tdAmountB0 = tdInfo.amountB0;
        this.account.tdVaultLiquidity = tdInfo.vaultLiquidity;
        if (tdInfo.markets.length > 0) {
          this.margins = tdInfo.markets.map((m) => ({
            bTokenAddress: getLensPropAlias('underlying', m),
            vTokenAddress: getLensPropAlias('vToken', m),
            bTokenSymbol: normalizeBNB(this.chainId, getLensPropAlias('underlyingSymbol', m)),
            vTokenSymbol: getLensPropAlias('vTokenSymbol', m),
            bTokenPrice: this.bTokens.find((b) => b.bTokenSymbol === normalizeBNB(this.chainId, getLensPropAlias('underlyingSymbol', m))).bTokenPrice,
            exchangeRate: m.exchangeRate || '',
            vTokenBalance: getLensPropAlias('vTokenBalance', m),
          }));
          for (let margin of this.margins) {
            margin.vaultBalance = (!margin.exchangeRate)
              ? margin.vTokenBalance
              : this.bTokenDecimals[margin.bTokenAddress]   // fix non-18 decimal bToken issue
                ? bg(
                  bg(margin.vTokenBalance).times(margin.exchangeRate),
                  18 - this.bTokenDecimals[margin.bTokenAddress]
                ).toString()
                : bg(margin.vTokenBalance).times(margin.exchangeRate).toString();
          }
        } else {
          this.margins = []
        }
        if (tdInfo.positions.length > 0) {
          this.positions = tdInfo.positions;
        } else {
          this.positions = []
        }
        //this.account.xvsBalance = await this.xvsToken.balanceOf(accountAddress)
        this.account.margin =
          this.account.pTokenId === "0"
            ? "0"
            : bg(tdInfo.amountB0).plus(tdInfo.vaultLiquidity).toString();

        // update timestamp
        this.init_timestamp = Date.now()
        // this.pending = false
      } else {
        this.account =  this.account || {}
      }
    }
  );

  klass = classAdapter(klass, 'getBTokens', async function (accountAddress) {
    if (Array.isArray(this.bTokens) && this.bTokens.length > 0) {
      if (accountAddress && accountAddress !== ADDRESS_ZERO) {

        // update user wallet balance
        const chainId = this.chainId
        const balances = await Promise.all(
          this.bTokens.reduce(
            (acc, b) => [
              ...acc,
              (async (b, accountAddress, chainId) => {
                return nativeCoinSymbols(chainId).includes(b.bTokenSymbol)
                  ? fromWei(await this.web3.eth.getBalance(accountAddress))
                  : await this[tokenToName(b.bTokenSymbol)].balanceOf(
                    accountAddress
                  );
              })(b, accountAddress, chainId),
            ],
            []
          )
        );
        for (let i = 0; i < this.bTokens.length; i++) {
          this.bTokens[i].walletBalance = balances[i] || '0';
        }
      }
      // update btoken decimals
      // if (!this.bTokens[0].bTokenDecimals) {
      //   const decimals = await Promise.all(
      //     this.bTokens.map((b) =>
      //       this[tokenToName(normalizeBNB(this.chainId, b.bTokenSymbol))].decimals()
      //     )
      //   );
      //   // use as non-18 decimals cache
      //   this.bTokenDecimals = {}
      //   // fix non-18 decimals bToken issue
      //   for (let i = 0; i < this.bTokens.length; i++) {
      //     this.bTokens[i].bTokenDecimals = decimals[i];
      //     if (decimals[i] !== '18') {
      //       this.bTokenDecimals[this.bTokens[i].bTokenAddress] = parseInt(decimals[i])
      //       this.bTokens[i].bTokenPrice = bg(this.bTokens[i].bTokenPrice, parseInt(decimals[i]) - 18).toString()
      //     }
      //   }
      // }
    }
  })

  klass = classAdapter(klass, 'getSymbols', async function () {
    if (Array.isArray(this.symbols) && this.symbols.length > 0) {
      this.symbols = this.symbols.map((s) => {
        //s.curTimestamp = Math.floor(Date.now()/1000)
        if (isOptionSymbol(s)) {
          s.intrinsicValue = getIntrinsicPrice(
            s.curIndexPrice,
            s.strikePrice,
            s.isCall
          );
          s.theoreticalPrice = bg(s.intrinsicValue)
            .plus(s.timeValue)
            .toString();
          s.fundingPerSecond = bg(s.fundingPeriod).eq(0)
            ? "0"
            : bg(s.markPrice)
                .minus(s.intrinsicValue)
                .div(s.fundingPeriod)
                .toString();
          s.initialMarginPerVolume = max(
            bg(getInitialMarginRequired(s)).times(
              bg(s.initialMarginRatio).div(s.maintenanceMarginRatio)
            ),
            bg(s.curIndexPrice).times(s.minInitialMarginRatio)
          ).abs().toString();
          s.maintenanceMarginPerVolume = getInitialMarginRequired(s).toString();
          //console.log(s.theoreticalPrice, s.K, s.netVolume, s.netCost)
          s.curTradersPnl = calculateDpmmCost(
              s.theoreticalPrice,
              s.K,
              s.netVolume,
              bg(s.netVolume).negated()
            )
              .negated()
              .minus(s.netCost)
              .toString();
        } else if (isPowerSymbol(s)) {
          // s.oneHT = bg(1).minus(
          //   bg(s.curVolatility)
          //     .times(s.curVolatility)
          //     .times(s.power)
          //     .times(bg(s.power).minus(1))
          //     .div(2)
          //     .times(s.fundingPeriod)
          //     .div(31536000)
          // ).toString()
          // s.powerPrice = bg(s.curIndexPrice).times(s.curIndexPrice).toString()
          // s.theoreticalPrice = bg(s.powerPrice).div(s.oneHT).toString()
          s.oneHT = bg(1).minus(s.hT).toString()
          s.fundingPerSecond = bg(s.fundingPeriod).eq(0)
            ? "0"
            : bg(s.markPrice)
                .minus(s.powerPrice)
                .div(s.fundingPeriod)
                .toString();
          s.curTradersPnl = calculateDpmmCost(
              s.theoreticalPrice,
              s.K,
              s.netVolume,
              bg(s.netVolume).negated()
            )
              .negated()
              .minus(s.netCost)
              .toString();
          s.maintenanceMarginPerVolume = bg(s.theoreticalPrice).times(s.maintenanceMarginRatio).toString()
          s.initialMarginPerVolume = bg(s.maintenanceMarginPerVolume)
            .times(s.initialMarginRatio)
            .div(s.maintenanceMarginRatio)
            .toString();
        } else {
          s.fundingPerSecond = bg(s.fundingPeriod).eq(0)
            ? "0"
            : bg(s.markPrice)
                .minus(s.curIndexPrice)
                .div(s.fundingPeriod)
                .toString();
          s.initialMarginPerVolume = bg(1)
            .times(s.curIndexPrice)
            .times(s.initialMarginRatio)
            .toString();
          s.maintenanceMarginPerVolume = bg(1)
            .times(s.curIndexPrice)
            .times(s.maintenanceMarginRatio)
            .toString();
          s.curTradersPnl = calculateDpmmCost(
              s.curIndexPrice,
              s.K,
              s.netVolume,
              bg(s.netVolume).negated()
            )
              .negated()
              .minus(s.netCost)
              .toString();
        }
        s.fundingPerDay = bg(s.fundingPerSecond)
          .times(SECONDS_IN_A_DAY)
          .toString();
        return s;
      });
      return this.symbols
    } else {
      // console.log("skip getSymbols");
      return []
    }
  });
  klass = classAdapter(klass, 'getAssets', async function () {
    // if (Array.isArray(this.assets) && this.assets.length > 0) {
    //   for (let i = 0; i < this.assets.length; i++) {
    //     let asset = this.assets[i];
    //     asset.vaultBalance = (!asset.exchangeRate)
    //       ? asset.vTokenBalance
    //       : this.bTokenDecimals[asset.bTokenAddress]   // fix non-18 decimal bToken issue
    //         ? bg(
    //           bg(asset.vTokenBalance).times(asset.exchangeRate),
    //           18 - this.bTokenDecimals[asset.bTokenAddress]
    //         ).toString()
    //         : bg(asset.vTokenBalance).times(asset.exchangeRate).toString();
    //     if (bg(asset.bTokenPrice).eq(0)) {
    //       asset.bTokenPrice = this.bTokens.find((b) => b.bTokenSymbol === asset.bTokenSymbol).bTokenPrice
    //     }
    //   }
    //   return this.assets
    // } else {
    //   // console.log("skip getAssets");
    //   return [];
    // }
  });
  klass = classAdapter(klass, 'getMargins', async function (accountAddress) {
    // if (Array.isArray(this.margins) && this.margins.length > 0) {
    //   for (let i = 0; i < this.margins.length; i++) {
    //     let margin = this.margins[i];
    //     margin.vaultBalance = (!margin.exchangeRate)
    //       ? margin.vTokenBalance
    //       : this.bTokenDecimals[margin.underlying]   // fix non-18 decimal bToken issue
    //         ? bg(
    //           bg(margin.vTokenBalance).times(margin.exchangeRate),
    //           18 - this.bTokenDecimals[margin.underlying]
    //         ).toString()
    //         : bg(margin.vTokenBalance).times(margin.exchangeRate).toString();
    //     if (bg(margin.bTokenPrice).eq(0)) {
    //       margin.bTokenPrice = this.bTokens.find((b) => b.bTokenSymbol === margin.bTokenSymbol).bTokenPrice
    //     }
    //   }
    //   return this.margins;
    // } else {
    //   // console.log('skip getMargins');
    //   return [];
    // }
  });
  klass = classAdapter(
    klass,
    'getPosition',
    async function (accountAddress, symbolName) {
      if (Array.isArray(this.positions) && this.positions.length > 0) {
        const position = this.positions.find((p) => p.symbol === symbolName);
        if (position) {
          return position;
        }
      }
      throw new Error('no position to close');
    }
  );
  klass = classAdapter(klass, 'getPositions', async function () {
    if (Array.isArray(this.positions)) {
      let fundingAccrued = '0',
        initialMargin = '0',
        maintenanceMargin = '0',
        traderPnl = '0',
        dpmmTraderPnl = '0';
      this.positions = this.positions.map((p) => {
        const symbol = this.symbols.find((s) => p.symbol === s.symbol);
        // console.log(symbol.symbol)
        if (symbol) {
          p.fundingAccrued = bg(p.volume)
            .times(
              bg(symbol.curCumulativeFundingPerVolume)
                //.plus(diff)
                .minus(p.cumulativeFundingPerVolume)
            )
            .toString();
          if (isOptionSymbol(symbol)) {
            const res = getInitialMarginRequired(symbol)
            p.initialMarginRequired = max(
              bg(res)
                .times(
                  bg(symbol.initialMarginRatio).div(
                    symbol.maintenanceMarginRatio
                  )
                )
                .abs(),
              bg(symbol.curIndexPrice).times(symbol.minInitialMarginRatio)
            ).times(p.volume).abs().toString();
            p.maintenanceMarginRequired = bg(symbol.maintenanceMarginPerVolume).times(p.volume).toString();
            p.traderPnl = bg(symbol.theoreticalPrice).times(p.volume).minus(p.cost).toString();
            p.dpmmTraderPnl = calculateDpmmCost(
              symbol.theoreticalPrice,
              symbol.K,
              symbol.netVolume,
              bg(p.volume).negated()
            )
              .negated()
              .minus(p.cost)
              .toString();
          } else if(isPowerSymbol(symbol)) {
            p.maintenanceMarginRequired = bg(p.volume)
              .abs()
              .times(symbol.maintenanceMarginPerVolume).toString();
            p.initialMarginRequired = bg(p.volume)
              .abs()
              .times(symbol.initialMarginPerVolume).toString();
            p.traderPnl = bg(symbol.theoreticalPrice).times(p.volume).minus(p.cost).toString();
            p.dpmmTraderPnl = calculateDpmmCost(
              symbol.theoreticalPrice,
              symbol.K,
              symbol.netVolume,
              bg(p.volume).negated()
            )
              .negated()
              .minus(p.cost)
              .toString();
          } else {
            p.initialMarginRequired = bg(p.volume)
              .abs()
              .times(symbol.curIndexPrice)
              .times(symbol.initialMarginRatio)
              .toString();
            p.maintenanceMarginRequired = bg(p.initialMarginRequired)
              .times(symbol.maintenanceMarginRatio)
              .div(symbol.initialMarginRatio)
              .toString();
            p.traderPnl = bg(symbol.curIndexPrice)
              .times(p.volume)
              .minus(p.cost)
              .toString();
            p.dpmmTraderPnl = calculateDpmmCost(
              symbol.curIndexPrice,
              symbol.K,
              symbol.netVolume,
              bg(p.volume).negated()
            )
              .negated()
              .minus(p.cost)
              .toString();
          }
          fundingAccrued = bg(fundingAccrued).plus(p.fundingAccrued)
          traderPnl = bg(traderPnl).plus(p.traderPnl)
          dpmmTraderPnl = bg(dpmmTraderPnl).plus(p.dpmmTraderPnl)
          initialMargin = bg(initialMargin).plus(p.initialMarginRequired)
          maintenanceMargin = bg(maintenanceMargin).plus(
            bg(p.maintenanceMarginRequired)
          );
        }
        return p;
      });
      if (this.account.address) {
        this.account.fundingAccrued = fundingAccrued.toString()
        this.account.traderPnl = traderPnl.toString()
        this.account.dpmmTraderPnl = dpmmTraderPnl.toString()
        this.account.initialMargin = initialMargin.toString()
        this.account.maintenanceMargin = maintenanceMargin.toString()
        this.account.dynamicMargin = bg(this.account.margin)
          //.minus(this.account.initialMargin)
          .minus(this.account.fundingAccrued)
          .plus(this.account.traderPnl)
          .toString();
      }
      return this.positions;
    } else {
      // console.log('skip getPositions');
      return [];
    }
  });

  klass = classAdapter(klass, 'getIsUnlocked', async function (accountAddress) {
    const isUnlocked = await Promise.all(
      this.bTokens.reduce(
        (acc, b) => [
          ...acc,
          this[tokenToName(b.bTokenSymbol)].isUnlocked(accountAddress, this.contractAddress),
        ],
        []
      )
    );
    //console.log("isUnlocked", isUnlocked);
    return isUnlocked;
  });

  klass = classAdapter(klass, 'getConfig', async function () {
    if (!Array.isArray(this.symbols)) {
      await Promise.all([
        this.getBTokens(),
        this.getSymbols(),
      ])
    }
    const bTokens = this.bTokens
    return {
      pool: this.contractAddress,
      pToken: this.addresses.pToken,
      lToken: this.addresses.lToken,
      xvsToken: this.addresses.xvsAddress,
      // bTokenSymbols: this.bTokenSymbols,
      bTokens: bTokens.map((b) => ({
        bTokenSymbol: b.bTokenSymbol,
        vTokenSymbol: b.vTokenSymbol,
        bToken: b.bTokenAddress,
        vToken: b.vToken,
      })),
      symbols: this.symbols.map((s, index) => ({
        symbolId: s.symbolId,
        symbol: s.symbol,
        unit: normalizeSymbolUnit(s.symbol),
      })),
      initialBlock: this.initialBlock,
      type: this.isOptionPool ? "option" : "future",
      zone: !this.isOptionPool ? (this.isFutureMainPool ? "main" : "inno") : "",
      version: 'v3',
      versionId: 'v3',
      chainId: this.chainId,
      chain: getNetworkName(this.chainId),
      env: DeriEnv.get(),
    };
  });

  klass = overrideMethods(klass, [
    [processMethod, 'minRatioB0'],
    [processMethod, 'reserveRatioB0'],
    [processMethod, 'liquidationRewardCutRatio'],
    [processMethod, 'maxLiquidationReward'],
    [processMethod, 'minLiquidationReward'],
    [processMethod, 'protocolFeeCollectRatio'],
    [processMethod, 'poolInitialMarginMultiplier'],

    [processMethod, 'liquidity'],
    [processMethod, 'protocolFeeAccrued'],
    [processMethod, 'lpsPnl'],
    [processMethod, 'cumulativePnlPerLiquidity'],

    [
      processMethod,
      'lpInfos',
      ['amountB0', 'cumulativePnlPerLiquidity', 'liquidity'],
    ],
    [processMethod, 'tdInfos', ['amountB0']],
    // [processTxMethod, 'addLiquidity', ['2']],
    // [processTxMethod, 'removeLiquidity', ['2']],
    // [processTxMethod, 'addMargin', ['2']],
    // [processTxMethod, 'removeMargin', ['2']],
    [processTxMethod, 'trade', ['2', '3']],
  ]);
  return klass;
}